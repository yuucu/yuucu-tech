---
title: "i32, i64, u32, u64の数値範囲まとめ"
date: 2021-01-17
slug: /20210117-rust-num-range
tags:
  - Rust
  - アルゴリズム
---

AtCoderで問題解く際に変数宣言する時に範囲大丈夫かな...   
と毎回なってしまうため、きちんと頭に入れておくためのメモです。




main.rs

```java
fn main() {
    println!("2^32: {}\n2^64: {}", 2_u128.pow(32), 2_u128.pow(64));

    let num_i32: i32 = 10_i32.pow(9);
    let num_i64: i64 = 10_i64.pow(18);
    println!("*i32: {}", num_i32);
    println!("*i64: {}", num_i64);

    let num_u32: u32 = 10_u32.pow(9);
    let num_u64: u64 = 10_u64.pow(19);
    println!("*u32: {}", num_u32);
    println!("*u32: {}", num_u64);
}
```

出力結果

```
2^32: 4294967296
2^64: 18446744073709551616
- i32: 1000000000
- i64: 1000000000000000000
- u32: 1000000000
- u32: 10000000000000000000
```

`unsigned`の場合は***0を含める必要がある***ため、   
`u32`の場合であれば、`0から2の32乗-1`となります。   

`i32`であればマイナスの値も必要になるため`u32`の半分の範囲になりますね。



| 型の名前| 値の範囲 | 桁数 |
| ---- | ---- | ---- |
|  i32  | -2147483648 ~ 2147483647 | 10^9 |
|  i64  | -9223372036854775808 ~ 9223372036854775807| 10^18 |
|  u32  | 0 ~ 4294967295 | 10^9 |
|  u64  | 0 ~ 18446744073709551614 | 10^19 |


32bit変数が10^9くらいは入るなと覚えておけば大丈夫そうですね...!
